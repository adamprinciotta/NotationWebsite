<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Gamepad → Combo Overlay (OBS-ready v13 · Global Chip Colors + Chip Editor)</title>
<style>
  /* ===== THEME & LIVE KNOBS ===== */
  :root{
    --fg:#e7e7ea;              /* base text (settings UI) */
    --bg:transparent;          /* keep overlay transparent for OBS */
    --panel:#1b1e25;           /* settings panel bg */
    --panel-brd:#2a2f3a;
    --accent:#3a4cff;
    --muted:#9aa3b2;

    /* overlay layout */
    --overlay-width:800px;
    --sep: ">";

    /* chip sizing */
    --chip-font:18px;
    --chip-img-h:20px;
    --chip-pad-x:12px;
    --chip-pad-y:6px;
    --chip-gap:10px;
    --chip-radius:999px;

    /* chip visuals (global override) */
    --chip-bg:#f5f5f5;         /* lighter default so black/grey direction art reads well */
    --chip-brd:rgba(0,0,0,.25);
    --chip-text:#000000;       /* default black text for readability on light BG */
  }

  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);
    font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,"Noto Sans"}
  *{box-sizing:border-box}

  /* ===== OVERLAY ===== */
  #overlayWrap{position:sticky;top:0;padding:10px 12px;
    background:linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,0));backdrop-filter:saturate(1.2)}
  #overlay{
    display:flex;flex-wrap:wrap;align-items:center;gap:var(--chip-gap);
    background:rgba(18,18,22,.66);border:1px solid rgba(255,255,255,.08);
    border-radius:14px;padding:8px 12px;min-height:48px;
    max-width:var(--overlay-width);overflow-x:auto;
  }
  .chip{
    display:inline-flex;align-items:center;gap:6px;
    font-weight:800;font-size:var(--chip-font);line-height:1;
    padding:var(--chip-pad-y) var(--chip-pad-x);
    border-radius:var(--chip-radius);
    background:var(--chip-bg);border:1px solid var(--chip-brd);
    color:var(--chip-text);
    user-select:none; cursor:default;
    outline:none;
  }
  .chip:focus{box-shadow:0 0 0 2px rgba(58,76,255,.6)}
  .chip.selected{box-shadow:0 0 0 2px #fff8;border-color:#fff}
  .img{height:var(--chip-img-h);vertical-align:middle}
  .sep{font-weight:900;opacity:.9;padding:0 6px;user-select:none}

  /* If user toggles global override, force all chips to use --chip-bg/--chip-text */
  .global-override .chip{ background:var(--chip-bg)!important; color:var(--chip-text)!important }

  /* ===== POPOVER (chip editor) ===== */
  .popover{
    position:fixed; z-index:10000; background:#151821; border:1px solid #2a2f3a; color:#e7ebf3;
    border-radius:10px; padding:8px; box-shadow:0 8px 26px rgba(0,0,0,.45); width:260px;
  }
  .popover h5{margin:0 0 6px;font-size:12px;color:#9aa3b2;font-weight:700;letter-spacing:.02em}
  .popover .row{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
  .popover .btn{appearance:none;border:1px solid #2a2f3a;border-radius:8px;padding:6px 10px;background:#30384b;color:#eef0f5;font-weight:700;cursor:pointer}
  .popover .btn.danger{background:#5b1b2a;border-color:#7d2236}
  .popover input[type="text"]{width:100%;padding:6px 8px;border-radius:8px;border:1px solid #2a2f3a;background:#262b36;color:#eef0f5}

  /* ===== SETTINGS LAYOUT ===== */
  .wrap{display:grid;grid-template-columns:1fr 400px;gap:12px;padding:8px 12px}
  .col{display:grid;gap:12px;align-content:start;max-height:calc(100vh - 120px);overflow:auto}
  .card{background:var(--panel);border:1px solid var(--panel-brd);border-radius:12px;padding:10px;box-shadow:0 4px 14px rgba(0,0,0,.25)}
  .row{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
  .btn{appearance:none;border:1px solid var(--panel-brd);border-radius:10px;padding:8px 10px;cursor:pointer;font-weight:700;background:#2a3040;color:#eef0f5}
  .btn.primary{background:var(--accent);border-color:transparent;color:white}
  .btn.ghost{background:transparent}
  select,input[type="number"],input[type="text"],input[type="color"]{
    width:100%;padding:6px 8px;border-radius:8px;border:1px solid var(--panel-brd);background:#262b36;color:#eef0f5;outline:none
  }
  select option{background:#262b36;color:#eef0f5}
  label{display:flex;align-items:center;gap:8px}
  table{width:100%;border-collapse:collapse}
  th,td{padding:6px 4px;border-bottom:1px dotted rgba(255,255,255,.12);font-size:13px;color:#e7ebf3}
  .tiny{font-size:12px;color:var(--muted)}
  body.obs .wrap{display:none}
</style>
</head>
<body>
  <!-- ===== OVERLAY (what OBS captures) ===== -->
  <div id="overlayWrap"><div id="overlay" aria-live="polite"></div></div>

  <!-- ===== SETTINGS (compact two columns) ===== -->
  <div class="wrap">
    <div class="col">
      <div class="card">
        <div class="row" style="grid-template-columns:1fr auto auto auto auto;gap:6px">
          <select id="profileSelect"></select>
          <button id="newProfile" class="btn">New</button>
          <button id="dupProfile" class="btn">Duplicate</button>
          <button id="delProfile" class="btn">Delete</button>
          <button id="saveProfile" class="btn primary">Save</button>
        </div>
        <div class="row">
          <input id="profileName" type="text" placeholder="Profile name"/>
          <div class="tiny">E: toggle settings · C: clear overlay</div>
        </div>
        <div class="row" style="grid-template-columns:1fr auto auto auto">
          <input id="importInput" type="file" accept="application/json" style="display:none" />
          <button id="exportBtn" class="btn">Export</button>
          <button id="importBtn" class="btn">Import</button>
          <button id="makeObsUrl" class="btn">Copy OBS URL</button>
        </div>
      </div>

      <div class="card">
        <div class="row" style="grid-template-columns:auto auto auto;gap:8px">
          <button id="clearBtn" class="btn">Clear now</button>
          <button id="copyBtn" class="btn">Copy text</button>
          <button id="toggleMode" class="btn primary">Mode: Live</button>
        </div>
        <div class="row" style="grid-template-columns:1fr 1fr;gap:8px;margin-top:6px">
          <label>Reset action<select id="resetAction"></select></label>
          <label>Facing<select id="facing"><option value="right">Facing Right (F=→)</option><option value="left">Facing Left (F=←)</option></select></label>
        </div>
      </div>

      <div class="card">
        <h4 style="margin:0 0 6px">Timing</h4>
        <div class="row"><label>Chord window (ms)<input id="chordWindow" type="number" value="80"></label><label>Repeat lockout (ms)<input id="repeatLockout" type="number" value="110"></label></div>
        <div class="row"><label>Hold threshold (ms) → [L]<input id="holdMs" type="number" value="250"></label><label>Deadzone<input id="deadzone" type="number" step="0.01" min="0" max="0.99" value="0.5"></label></div>
        <div class="row"><label>Motion window (ms)<input id="motionWindow" type="number" value="700"></label><label>Motion→Button couple (ms)<input id="motionCoupleMs" type="number" value="130"></label></div>
        <div class="row"><label>Charge frames (60fps)<input id="chargeFrames" type="number" value="30"></label><label>Charge→Opposite+Btn (ms)<input id="chargeWindow" type="number" value="180"></label></div>
      </div>

      <div class="card">
        <h4 style="margin:0 0 6px">Overlay Size & Colors</h4>
        <div class="row"><label>Chip font (px)<input id="chipFont" type="number" value="18"></label><label>Icon height (px)<input id="chipImgH" type="number" value="20"></label></div>
        <div class="row"><label>Chip pad X<input id="chipPadX" type="number" value="12"></label><label>Chip pad Y<input id="chipPadY" type="number" value="6"></label></div>
        <div class="row"><label>Chip gap<input id="chipGap" type="number" value="10"></label><label>Chip radius<input id="chipRadius" type="number" value="999"></label></div>
        <div class="row"><label>Overlay width (px)<input id="overlayWidth" type="number" value="800"></label><label>Separator<input id="separator" type="text" value=">"></label></div>
        <div class="row"><label>Global chip background<input id="chipBgAll" type="color" value="#f5f5f5"></label><label>Global chip text<input id="chipTextAll" type="color" value="#000000"></label></div>
        <div class="row"><label style="grid-column:1/-1;gap:10px"><input id="useGlobalColors" type="checkbox" checked> Force all chips to use the global colors above</label></div>
      </div>
    </div>

    <div class="col">
      <div class="card">
        <h4 style="margin:0 0 6px">Buttons (label, text color, chip bg)</h4>
        <table id="buttonMapTable"></table>
      </div>
      <div class="card"><div id="status" class="tiny">No gamepad detected. Press any button. Drag & drop a JSON to import. Click a chip to edit; Delete to remove; double-click to rename.</div></div>
    </div>
  </div>

  <script>
  const overlay=document.getElementById('overlay');
  const q=new URLSearchParams(location.search);
  if(q.get('obs')==='1'||window.obsstudio){document.body.classList.add('obs');}
  if(q.get('edit')==='1'){document.body.classList.remove('obs');}
  window.addEventListener('keydown',(e)=>{const k=e.key.toLowerCase(); if(k==='e') document.body.classList.toggle('obs'); if(k==='c') clearOverlay(); if((k==='delete'||k==='backspace') && currentSelectedChip){ removeChip(currentSelectedChip); }});
  const $=(s)=>document.querySelector(s);

  /* ======= Profiles ======= */
  const LS_PROFILES='gp_profiles_obs_v13';
  const LS_ACTIVE='gp_active_profile_obs_v13';
  const DEFAULT_BUTTON_LABELS=['L','M','H','S','LB','RB','LT','RT','Select','Start','L3','R3','D↑','D↓','D←','D→'];
  const DEFAULT_BUTTON_COLORS=Array(16).fill('#000000');     // black text works on light bg
  const DEFAULT_BUTTON_BG=Array(16).fill('#f5f5f5');         // light default
  function defaultProfile(){return {name:'Default',buttonLabels:[...DEFAULT_BUTTON_LABELS],buttonColors:[...DEFAULT_BUTTON_COLORS],buttonBgColors:[...DEFAULT_BUTTON_BG],deadzone:0.5,chordWindow:80,repeatLockout:110,holdMs:250,motionWindow:700,motionCoupleMs:130,chargeFrames:30,chargeWindow:180,facing:'right',resetAction:'none',separator:'>'}};
  function loadProfiles(){try{const raw=localStorage.getItem(LS_PROFILES); if(!raw) return [defaultProfile()]; const arr=JSON.parse(raw); return Array.isArray(arr)&&arr.length?arr:[defaultProfile()];}catch{return [defaultProfile()];}}
  function saveProfiles(){localStorage.setItem(LS_PROFILES, JSON.stringify(profiles));}
  function loadActive(){const v=parseInt(localStorage.getItem(LS_ACTIVE)||'0',10);return Number.isFinite(v)&&v>=0&&v<profiles.length? v:0;}
  function saveActive(){localStorage.setItem(LS_ACTIVE, String(activeProfile));}
  let profiles=loadProfiles(); let activeProfile=loadActive();

  // Import via ?config (base64) or ?configUrl
  (async function bootConfigFromQuery(){
    try{
      if(q.get('config')){
        const json=JSON.parse(atob(q.get('config'))); if(Array.isArray(json)&&json.length){ profiles=json; activeProfile=0; saveProfiles(); saveActive(); }
      }else if(q.get('configUrl')){
        const url=q.get('configUrl'); if(/^https?:/i.test(url)){ const res=await fetch(url,{cache:'no-store'}); const json=await res.json(); if(Array.isArray(json)&&json.length){ profiles=json; activeProfile=0; saveProfiles(); saveActive(); } }
      }
    }catch(e){ console.warn('Config import error', e); }
  })();

  // UI refs
  const profileSelect=$('#profileSelect'), profileName=$('#profileName');
  const newProfileBtn=$('#newProfile'), dupProfileBtn=$('#dupProfile'), delProfileBtn=$('#delProfile'), saveProfileBtn=$('#saveProfile');
  const exportBtn=$('#exportBtn'), importBtn=$('#importBtn'), importInput=$('#importInput');
  const makeObsUrlBtn=$('#makeObsUrl');
  const buttonMapTable=$('#buttonMapTable');
  const resetSel=$('#resetAction'); const facingSel=$('#facing'); const statusEl=$('#status');

  // Size & global color refs
  const chipFontInp=$('#chipFont'), chipImgHInp=$('#chipImgH'), chipPadXInp=$('#chipPadX'), chipPadYInp=$('#chipPadY'),
        chipGapInp=$('#chipGap'), chipRadiusInp=$('#chipRadius'), overlayWidthInp=$('#overlayWidth'),
        separatorInp=$('#separator'),
        chipBgAllInp=$('#chipBgAll'), chipTextAllInp=$('#chipTextAll'), useGlobalColors=$('#useGlobalColors');

  function applyCssKnobs(){
    document.documentElement.style.setProperty('--chip-font', chipFontInp.value+'px');
    document.documentElement.style.setProperty('--chip-img-h', chipImgHInp.value+'px');
    document.documentElement.style.setProperty('--chip-pad-x', chipPadXInp.value+'px');
    document.documentElement.style.setProperty('--chip-pad-y', chipPadYInp.value+'px');
    document.documentElement.style.setProperty('--chip-gap', chipGapInp.value+'px');
    document.documentElement.style.setProperty('--chip-radius', chipRadiusInp.value+'px');
    document.documentElement.style.setProperty('--overlay-width', overlayWidthInp.value+'px');
    document.documentElement.style.setProperty('--chip-bg', chipBgAllInp.value);
    document.documentElement.style.setProperty('--chip-text', chipTextAllInp.value);
    document.body.classList.toggle('global-override', !!useGlobalColors.checked);
  }

  function refreshProfileUI(){ if(activeProfile<0||activeProfile>=profiles.length) activeProfile=0; const p=profiles[activeProfile];
    profileSelect.innerHTML=profiles.map((pp,i)=>`<option value="${i}" ${i===activeProfile?'selected':''}>${escapeHtml(pp.name||`Profile ${i+1}`)}</option>`).join('');
    profileName.value=p.name||''; renderButtonMap();
    resetSel.innerHTML = ['none', ...Array.from({length:16},(_,i)=>`button:${i}`)].map(v=>`<option value="${v}" ${p.resetAction===v?'selected':''}>${v}</option>`).join('');
    facingSel.value=p.facing||'right';
    $('#deadzone').value=p.deadzone; $('#chordWindow').value=p.chordWindow; $('#repeatLockout').value=p.repeatLockout; $('#holdMs').value=p.holdMs; $('#motionWindow').value=p.motionWindow; $('#motionCoupleMs').value=p.motionCoupleMs; $('#chargeFrames').value=p.chargeFrames; $('#chargeWindow').value=p.chargeWindow;
    applyCssKnobs();
  }
  function renderButtonMap(){ const p=profiles[activeProfile]; let rows='<tr><th>#</th><th>Label</th><th>Text</th><th>Chip BG</th></tr>'; const N=Math.max(16,p.buttonLabels.length);
    for(let i=0;i<N;i++){ const label=p.buttonLabels[i]??''; const color=p.buttonColors[i]??'#000000'; const bg=p.buttonBgColors[i]??'#f5f5f5';
      rows+=`<tr><td>#${i}</td><td><input data-btn="${i}" class="btn-label" type="text" value="${escapeHtml(label)}"></td><td><input data-btn-color="${i}" class="btn-color" type="color" value="${color}"></td><td><input data-btn-bg="${i}" class="btn-bg" type="color" value="${bg}"></td></tr>`; }
    buttonMapTable.innerHTML=rows;
  }

  profileSelect?.addEventListener('change',e=>{activeProfile=parseInt(e.target.value,10);saveActive();refreshProfileUI();});
  newProfileBtn?.addEventListener('click',()=>{profiles.push(defaultProfile());activeProfile=profiles.length-1;saveProfiles();saveActive();refreshProfileUI();});
  dupProfileBtn?.addEventListener('click',()=>{const copy=JSON.parse(JSON.stringify(profiles[activeProfile])); copy.name=(copy.name||'Profile')+' (copy)'; profiles.push(copy); activeProfile=profiles.length-1; saveProfiles(); saveActive(); refreshProfileUI();});
  delProfileBtn?.addEventListener('click',()=>{ if(profiles.length<=1) return; profiles.splice(activeProfile,1); activeProfile=0; saveProfiles(); saveActive(); refreshProfileUI();});
  saveProfileBtn?.addEventListener('click',()=>{ const p=profiles[activeProfile]; p.name=profileName.value.trim()||`Profile ${activeProfile+1}`; p.facing=facingSel.value; p.resetAction=resetSel.value; p.separator=separatorInp.value||'>'; p.deadzone=parseFloat($('#deadzone').value)||p.deadzone; p.chordWindow=parseInt($('#chordWindow').value)||p.chordWindow; p.repeatLockout=parseInt($('#repeatLockout').value)||p.repeatLockout; p.holdMs=parseInt($('#holdMs').value)||p.holdMs; p.motionWindow=parseInt($('#motionWindow').value)||p.motionWindow; p.motionCoupleMs=parseInt($('#motionCoupleMs').value)||p.motionCoupleMs; p.chargeFrames=parseInt($('#chargeFrames').value)||p.chargeFrames; p.chargeWindow=parseInt($('#chargeWindow').value)||p.chargeWindow; saveProfiles(); refreshProfileUI();});

  exportBtn?.addEventListener('click',()=>{const blob=new Blob([JSON.stringify(profiles,null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='gamepad_profiles.json'; a.click(); URL.revokeObjectURL(url);});
  importBtn?.addEventListener('click',()=>importInput.click());
  importInput?.addEventListener('change',async(e)=>{const f=e.target.files?.[0]; if(!f) return; const text=await f.text(); try{ const arr=JSON.parse(text); if(Array.isArray(arr)&&arr.length){ profiles=arr; activeProfile=0; saveProfiles(); saveActive(); refreshProfileUI(); } }catch{} });
  makeObsUrlBtn?.addEventListener('click',()=>{ try{ const b64=btoa(JSON.stringify(profiles)); const here=location.href.split('?')[0]; const url=`${here}?obs=1&config=${b64}`; navigator.clipboard?.writeText(url); statusEl.textContent='Copied OBS URL with embedded config'; }catch{ statusEl.textContent='Could not encode config (too large?)'; }});

  // Live CSS knobs + global override
  document.addEventListener('input',(e)=>{
    const p=profiles[activeProfile]; if(!p) return; const t=e.target;
    if(t.matches('.btn-label')) p.buttonLabels[parseInt(t.dataset.btn,10)] = t.value;
    if(t.matches('.btn-color')) p.buttonColors[parseInt(t.dataset.btnColor,10)] = t.value;
    if(t.matches('.btn-bg')) p.buttonBgColors[parseInt(t.dataset.btnBg,10)] = t.value;
    if([chipFontInp,chipImgHInp,chipPadXInp,chipPadYInp,chipGapInp,chipRadiusInp,overlayWidthInp,chipBgAllInp,chipTextAllInp].includes(t)) applyCssKnobs();
    if(t===separatorInp){ p.separator=separatorInp.value||'>'; rebuildBuffer(); }
    if(t===useGlobalColors){ applyCssKnobs(); }
    saveProfiles();
  });

  /* ======= Drag & Drop import ======= */
  ;['dragenter','dragover','drop','dragleave'].forEach(evt=>window.addEventListener(evt,(e)=>{ if(evt!=='drop') e.preventDefault(); if(evt==='drop'){ const f=e.dataTransfer?.files?.[0]; if(f){ f.text().then(txt=>{ try{const arr=JSON.parse(txt); if(Array.isArray(arr)&&arr.length){ profiles=arr; activeProfile=0; saveProfiles(); saveActive(); refreshProfileUI(); statusEl.textContent='Imported profile (drag & drop)'; } }catch{} }); } } }));

  /* ======= Overlay helpers ======= */
  function addSeparator(){ if(overlay.children.length){const s=document.createElement('span');s.className='sep'; s.textContent=(profiles[activeProfile].separator||'>'); overlay.appendChild(s);} }
  function stripHTML(s){ return s.replace(/<[^>]+>/g,''); }

  function currentSeparator(){ return ' ' + (profiles[activeProfile].separator||'>') + ' '; }

  function rebuildBuffer(){
    // Build textual buffer from current chips
    const chips=[...overlay.querySelectorAll('.chip')];
    const parts=chips.map(ch=>ch.innerText.trim());
    buffer = parts;
  }

  let buffer=[];

  function addChipElHTML(html, perButtonBg){
    if(overlay.children.length) addSeparator();
    const c=document.createElement('span'); c.className='chip'; c.innerHTML=html;
    c.tabIndex=0; // focusable
    if(!useGlobalColors.checked && perButtonBg) c.style.backgroundColor = perButtonBg;

    // Chip interactions
    c.addEventListener('click', (ev)=>{ selectChip(c); openPopover(c); ev.stopPropagation(); });
    c.addEventListener('dblclick', (ev)=>{ selectChip(c); openPopover(c, true); ev.stopPropagation(); });

    overlay.appendChild(c);
    overlay.scrollLeft=overlay.scrollWidth;

    rebuildBuffer();
    return c;
  }

  function clearOverlay(){ overlay.innerHTML=''; buffer.length=0; activeButtonChips.clear(); lastCharged={tok:null,at:0}; closePopover(); currentSelectedChip=null; }
  $('#clearBtn')?.addEventListener('click', clearOverlay);
  $('#copyBtn')?.addEventListener('click', ()=>{ const txt=buffer.join(currentSeparator().trim()); navigator.clipboard?.writeText(txt); });
  let modeLive=true; $('#toggleMode')?.addEventListener('click',()=>{ modeLive=!modeLive; $('#toggleMode').textContent='Mode: '+(modeLive?'Live':'Record'); });

  /* ======= Gamepad ======= */
  let gamepadIndex=null; let prevButtons=[]; let lastButtonTime=new Map();
  const activeButtonChips=new Map(); // idx -> {chip,label,pressAt,held}
  window.addEventListener('gamepadconnected',e=>{gamepadIndex=e.gamepad.index;prevButtons=e.gamepad.buttons.map(b=>b.pressed); statusEl.textContent=`Connected: ${e.gamepad.id}`;});
  window.addEventListener('gamepaddisconnected',()=>{gamepadIndex=null; statusEl.textContent='Gamepad disconnected';});
  function now(){return performance.now();}
  function poll(){const gps=navigator.getGamepads?.(); let gp=(gamepadIndex!=null)?gps[gamepadIndex]:null; if(!gp){for(const g of gps){if(g){gp=g;gamepadIndex=g.index;prevButtons=g.buttons.map(b=>b.pressed);break;}}}
    if(gp){handleButtons(gp);trackDirections(gp);} requestAnimationFrame(poll);} requestAnimationFrame(poll);

  /* ======= Directions & motions ======= */
  function tokenFromAxes(ax,ay,dz=0.5){let h=null,v=null;if(Math.abs(ax)>=dz)h=ax<0?'l':'r';if(Math.abs(ay)>=dz)v=ay<0?'u':'d';if(h&&v)return v+h;return h||v||'n';}
  function dirToImg(tok){const map={u:'u',d:'d',l:'b',r:'f',ul:'ub',ur:'uf',dl:'db',dr:'df'};if(!map[tok])return null;return `<img class="img" src="images/${map[tok]}.png" alt="${map[tok]}">`;}
  let dirHistory=[];
  function trackDirections(gp){const p=profiles[activeProfile]; const dU=gp.buttons[12]?.pressed, dD=gp.buttons[13]?.pressed, dL=gp.buttons[14]?.pressed, dR=gp.buttons[15]?.pressed; let tok='n'; if(dL) tok='l'; else if(dR) tok='r'; if(dU) tok=(tok==='r')?'ur':(tok==='l')?'ul':'u'; else if(dD) tok=(tok==='r')?'dr':(tok==='l')?'dl':'d'; if(tok==='n') tok=tokenFromAxes(gp.axes[0]||0,gp.axes[1]||0,p.deadzone||0.5); const t=now(); if(!dirHistory.length||dirHistory[dirHistory.length-1].token!==tok){ dirHistory.push({t,token:tok}); const win=Math.max(700, p.motionWindow||700)+200; while(dirHistory.length && (t-dirHistory[0].t) > win) dirHistory.shift(); } updateCharge(tok); }
  function facingMap(tok){ if((profiles[activeProfile].facing||'right')==='right') return tok; return tok.replace(/l/g,'R').replace(/r/g,'l').replace(/R/g,'r'); }
  function compressedSeqWithin(ms){ const t=now(), start=t-ms; const seq=dirHistory.filter(e=>e.t>=start).map(e=>e.token).filter(x=>x!=='n').map(facingMap); const comp=[]; for(const s of seq){ if(!comp.length||comp[comp.length-1]!==s) comp.push(s);} return comp; }
  function matchPattern(seq, pattern){ let i=0; for(const p of pattern){ i=seq.indexOf(p,i); if(i===-1) return false; i++; } return true; }
  function detectMotionForButton(){ const p=profiles[activeProfile]; const seq=compressedSeqWithin(p.motionWindow||700);
    const tests=[ ['qcf',['d','dr','r']], ['qcb',['d','dl','l']], ['dpf',['r','d','dr']], ['dpb',['l','d','dl']], ['hcf',['l','d','r']], ['hcb',['r','d','l']] ];
    for(const [key,pat] of tests){ if(matchPattern(seq,pat)) return `<img class="img" src="images/${key}.png" alt="${key}">`; }
    const set=new Set(seq); if(['u','d','l','r'].every(k=>set.has(k))) return `<img class="img" src="images/360.png" alt="360">`;
    return null; }
  function snapshotDirection(){ const last=dirHistory.length?dirHistory[dirHistory.length-1].token:'n'; return last==='n'?null:last; }

  /* ======= Charge (horizontal + vertical) ======= */
  let currentDirTok='n', currentDirStart=0, lastCharged={tok:null, at:0};
  function updateCharge(latestTok){ const p=profiles[activeProfile]; const t=now(); if(latestTok!==currentDirTok){ if(currentDirTok!=='n'){ const heldMs=t-currentDirStart; const needMs=(p.chargeFrames||30)*(1000/60); if(heldMs>=needMs){ lastCharged={tok:currentDirTok, at:t}; } } currentDirTok=latestTok; currentDirStart=t; } }
  function isOpposite(a,b){ if(a.includes('l') && b.includes('r')) return true; if(a.includes('r') && b.includes('l')) return true; if(a.includes('u') && b.includes('d')) return true; if(a.includes('d') && b.includes('u')) return true; return false; }

  /* ======= Buttons & holds ======= */
  const holdTimers=new Map();
  function handleButtons(gp){ const p=profiles[activeProfile]; if(!prevButtons.length) prevButtons=gp.buttons.map(b=>b.pressed); const t=now(); const justPressed=[], justReleased=[];
    for(let i=0;i<gp.buttons.length;i++){
      const pressed=!!gp.buttons[i].pressed, was=!!prevButtons[i];
      if(pressed && !was){ const last=lastButtonTime.get(i)||0; if(t-last >= (p.repeatLockout||110)){
          if((p.resetAction||'none')===`button:${i}`){ clearOverlay(); lastButtonTime.set(i,t); prevButtons[i]=pressed; continue; }
          justPressed.push(i); lastButtonTime.set(i,t);
        } }
      if(!pressed && was){ justReleased.push(i); }
      prevButtons[i]=pressed;
    }

    for(const i of justPressed){ if(i>=12&&i<=15) continue; let html=null;
      // Charge couple (prevents dup)
      const age=t-(lastCharged.at||0); const nowDir=snapshotDirection()||'';
      if(lastCharged.tok && age <= (p.chargeWindow||180) && isOpposite(lastCharged.tok, nowDir)){
        const first=dirToImg(lastCharged.tok)||lastCharged.tok.toUpperCase();
        const second=dirToImg(nowDir)||nowDir.toUpperCase();
        html = `${first} ${second} ${buttonHTML(i)}`; lastCharged.tok=null;
      }
      // Motion couple
      if(!html){ const motionHTML=detectMotionForButton(); if(motionHTML){ html = `${motionHTML} ${buttonHTML(i)}`; } }
      // Direction + button
      if(!html){ const dirTok=snapshotDirection(); if(dirTok){ const dirHTML=dirToImg(dirTok)||dirTok.toUpperCase(); html = `${dirHTML} + ${buttonHTML(i)}`; } else { html = buttonHTML(i); } }

      const chip = addChipElHTML(html, (profiles[activeProfile].buttonBgColors[i]||'#f5f5f5'));
      activeButtonChips.set(i,{chip,label:(profiles[activeProfile].buttonLabels[i]||`#${i}`),pressAt:t,held:false});
      const holdId=setTimeout(()=>{ const obj=activeButtonChips.get(i); if(!obj) return; obj.held=true; mutateLabelText(obj.chip, obj.label, `[${obj.label}]`); rebuildBuffer(); }, p.holdMs||250); holdTimers.set(i,holdId);
    }

    for(const i of justReleased){ const obj=activeButtonChips.get(i); clearTimeout(holdTimers.get(i)); holdTimers.delete(i); if(obj){ if(obj.held){ addChipElHTML(buttonHTML(i, `]${obj.label}[`), (profiles[activeProfile].buttonBgColors[i]||'#f5f5f5')); } activeButtonChips.delete(i); rebuildBuffer(); } }
  }

  function buttonHTML(btnIndex, override){ const p=profiles[activeProfile]; const text = override ?? (p.buttonLabels[btnIndex] || `#${btnIndex}`); const color = useGlobalColors.checked ? getComputedStyle(document.documentElement).getPropertyValue('--chip-text').trim() : (p.buttonColors[btnIndex] || '#000000'); return `<span style="color:${color}">${escapeHtml(text)}</span>`; }

  function mutateLabelText(chipEl, oldText, newText){
    const spans=chipEl.querySelectorAll('span');
    for(let i=spans.length-1;i>=0;i--){ const sp=spans[i]; if(sp.textContent.trim()===oldText){ sp.textContent=newText; return; } }
    chipEl.innerHTML = chipEl.innerHTML.replace(new RegExp(escapeRegExp(oldText)+'(?!.*'+escapeRegExp(oldText)+')'),' '+newText+' ');
  }
  function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\\]\\\\]/g,'\\\\$&'); }
  function escapeHtml(s=''){ return s.replace(/[&<>\"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }

  /* ===== Chip selection + editor popover ===== */
  let currentSelectedChip=null, popEl=null;

  // clicking outside closes popover/selection
  document.addEventListener('click', (e)=>{ if(popEl && !popEl.contains(e.target) && currentSelectedChip && !currentSelectedChip.contains(e.target)){ closePopover(); deselectChip(); } });

  function selectChip(chip){
    if(currentSelectedChip===chip) return;
    deselectChip();
    currentSelectedChip=chip;
    chip.classList.add('selected');
    chip.focus();
  }
  function deselectChip(){
    if(currentSelectedChip){ currentSelectedChip.classList.remove('selected'); currentSelectedChip=null; }
  }

  function openPopover(chip, startInEdit=false){
    closePopover();
    const rect=chip.getBoundingClientRect();
    const p=document.createElement('div'); p.className='popover';
    p.style.left = Math.max(8, Math.min(window.innerWidth-280, rect.left))+'px';
    p.style.top  = (rect.bottom + 6)+'px';
    p.innerHTML = `
      <h5>Chip actions</h5>
      <div class="row" style="grid-template-columns:1fr auto">
        <input id="renameInput" type="text" placeholder="New label…" />
        <button id="applyBtn" class="btn">Apply</button>
      </div>
      <div class="row" style="margin-top:8px;grid-template-columns:1fr auto">
        <div class="tiny">Tip: Press Delete/Backspace to remove</div>
        <button id="delBtn" class="btn danger">Delete</button>
      </div>`;
    document.body.appendChild(p);
    popEl=p;

    const renameInput=$('#renameInput'), applyBtn=$('#applyBtn'), delBtn=$('#delBtn');
    // prefill with current label text (best effort: last span text)
    const lastSpan = chip.querySelector('span:last-of-type');
    renameInput.value = lastSpan ? lastSpan.textContent.trim() : '';
    if(startInEdit) renameInput.focus();

    applyBtn.addEventListener('click', ()=>{
      const oldTxt = lastSpan ? lastSpan.textContent.trim() : '';
      const newTxt = renameInput.value.trim();
      if(newTxt && oldTxt && newTxt!==oldTxt){ mutateLabelText(chip, oldTxt, newTxt); rebuildBuffer(); }
      closePopover();
    });
    delBtn.addEventListener('click', ()=>{ removeChip(chip); closePopover(); });
  }

  function closePopover(){ if(popEl){ popEl.remove(); popEl=null; } }

  // Remove chip and tidy separators
  function removeChip(chip){
    if(!chip) return;
    const prev = chip.previousSibling, next = chip.nextSibling;
    // Prefer remove a preceding separator if present, else the following
    if(prev && prev.classList && prev.classList.contains('sep')) prev.remove();
    else if(next && next.classList && next.classList.contains('sep')) next.remove();
    chip.remove();
    if(currentSelectedChip===chip) currentSelectedChip=null;
    rebuildBuffer();
  }

  /* ===== Init ===== */
  refreshProfileUI();
  applyCssKnobs();
  </script>
</body>
</html>

